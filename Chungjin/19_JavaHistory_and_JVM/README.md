**JDK : Java develpoement kit**

**JRE : Java Runtime Enviroment - 자바를 실행할 수 있는 환경의 집합.** 

![JAVA](https://user-images.githubusercontent.com/46278436/195395892-aa85750a-945f-44e3-9820-5335a69bd170.PNG)

[참조](https://docs.oracle.com/javase/8/docs/index.html)
자바의


<br><br>

◼ 언어의 특징은 다음과 같다.

### ◼ 자바 언어의 특징

1. **자바는 단순하고, “객체지향이며, 친숙”해야 한다.**
    - 자바는 처음 만들어 질 때 객체지향으로 디자인 되었다.
2. **자바는 “견고하며, 보안상 안전”하다**
    - 자바는 컴파일 할 때 문법적 오류에 대한 체크를 한다.
    - 자바는 기본적으로 분산 환경에서 사용하기 위해서 디자인되었다.
    - 자바 기술은 외부에서 침입이 불가능한 애플리케이션을 만들 수 있도록 해준다.
    - 네트워크 환경에서 클라이언트로 다운로드한 승인받지 않은 프로그램은 실행할 수 없도록 되어 있다.
3. **자바는 “아키텍처에 중립적이어야 하며 포터블”해아 한다.**
    - 자바의 버전만 동일하다면, 동일한 프로그램은 어떤 플랫폼에서도 실행할 수 있다.
4. **자바는 “높은 성능”을 제공해야 한다.**
    - 자동화된  GC는 낮은 순위의 쓰레드로 동작하기 때문에 보다 높은 성능을 낼 수 있다.
5. **자바는 “인터프리트 언어이며, 쓰레드를 제공하고, 동적인 언어”이다.**
    - 자바 인터프리터는 자바 바이트 코트를 어떤 장비에서도 수행할 수 있도록 해준다.
    - 자바는 멀티 쓰레드 환경을 제공하기 때문에, 동시에 여러 작업을 수행할 수 있다.
    - 자바 컴파일러는 컴파일시 매우 엄격한 정적인 점검을 수행한다. 그리고, 실행시에 동적으로 필요한 프로그램을 링크시킨다.

<Br><br>

---

### ◼ JIT 컴파일러

- Just -In - Time 사용하는 언어 : JAVA, .NET
- 인터프리터 방식 + 정적 컴파일러 방식을 혼합한 방식

> **JIT는 다른 말로 동적 변환이라고 보면 된다.**
> 

**JIT 등장 이유?**

프로그램 실행을 보다 빠르게 하기 위해서다. 명칭이 컴파일러이지만, 실행시에 적용되는 기술이다. 

**컴퓨터를 실행하는 방식 두 가지** 

1. **인터프리터 방식** : 프로그램을 실행할 때 마다 컴퓨터가 알아 들을 수 있는 언어로 변환하는 작업.
    - 성능이 컴파일러 방식에 비해 느리다.
2. **정적(static) 컴파일러 방식** : 컴퓨터가 실행하기 전에 컴퓨터가 알아 들을 수 있는 언어로 변환하는 작업. 
    - 실행하기 전에 컴퓨터가 알아 들을 수 있는 언어로 변환하는 작업을 수행한다. 변환 작업은 딱 한번만 수행한다.

[JIT 컴파일 - 위키백과, 우리 모두의 백과사전](https://ko.wikipedia.org/wiki/JIT_%EC%BB%B4%ED%8C%8C%EC%9D%BC)

---

### ◼ HotSpot

- HotSpot이라는 이름을 사용하는 것은 JDK 1.3 전에 나왔던 가상 머신과 구분하기 위한 이름이라고 생각하면 된다.
- 자바에서는 “HotSpot 클라이언트 컴파일러”와 “HotSpot 서버 컴파일러”의 두 가지 컴파일러를 제공한다.

**HOTSPOT 등장 이유?**

- 예전에는 PC에서만 수행되는 프로그램을 사용할 때에는 많은 CPU 코어를 사용할 수 없었다.
- 코어가 많은 장비에서 애플리케이션을 돌리기 위해서 만들어진 것이 HotSpot 서버 컴파일러라고 생각하면 된다.

**특징** 

- 애플리케이션 시작 시간을 빠르게 하고, 적은 메모리를 점유하도록 할 수 있다.

**클라이언트 컴파일러와 서버 컴파일러는 어떻게 선택할 수 있을까**

: 자바가 시작할 때 알아서 클라이언트 장비인지 서버 장비인지를 확인한다. 그 기준은 아래와 같다.

- 2개 이상의 물리적 프로세서
- 2GB 이상의 물리적 메모리

명시적으로 어떤 종류의 jvm인지 지정하고 싶다면 서 JVM은 `-server` 라고 지정해주면 된다.

아래와 같이 java 명령과 클래스 이름 사이에 옵션을 추가하면 된다.

```bash
$java -server Calulator
```

JVM의 시작 메모리 크기를 지정하는 -Xms  옵션. 

```bash
$java -server -Xms512m Calculator
```

---

 

### ◼ GC

: 객체를 생성하더라도 그 객체는 언젠가는 메모리에서 지워주어야 하는데 GC ( Garbage collector)가 그 역할을 해준다.

- Yong Generation : 젊은 객체들이 존재한다.
- Old Generation : 늙은 객체들이 자리하고 있다.
- Perm : 클래스나 메서드에 대한 정보가 많이 쌓인다.  (Perm에 저장되는 데이터는 더 많지만, 이 정도만 알고 있어도 된다. )



1) Eden 영역에 객체가 생성된다.

2) Eden 영역이 꽉 차면 살아있는 객체만 Survior 영역으로 복사되고, 다시 Eden 영역을 채우게 된다.

3) Survior0 영역이 꽉 차게 되면 다른 Survivor1 영역으로 객체가 복사된다. 이 때, Eden 영역에 있는 객체들 중 살아있는 객체들도 다른 Survior 영역으로 간다. 즉, Survivor 영역의 둘 중 하나는 반드시 비어 있어야만 한다.

**Yong Generation  (Minor GC)  vs    Old Generation  (Full GC)**

- Yong GC 가 Full GC보다 빠르다. WHY?
    - 일반적으로 더 작은 공간이 할당되고, 객체들을 처리하는 방식도 다르기 때문이다.  그렇다고 전체 힙 영역을 영 영역으로 만들면 장애로 이어질 확률이 매우 높아진다.

**GC 방식 5가지**

: JDK 에서 제공하는 GC의 방식은 4가지가 있으며, Java 7부터 추가된 GI를 포함하여 총 5가지의 GC가 존재한다.

- Serial GC :  클라이언트에 최적화된 장비. ( WAS에서 사용하면 안된다. )
- Parallel Young Generation Collector
- Parallel Old Generation Collector
- Concurrent Mark & Sweep Collector (줄여서 CMS)
- G1(Garbage First)

WAS로 사용하는 JVM에서 사용하면 안되는 것은 Serial GC 다. **이 GC 방식은 —client 옵션을 지정했을 때 사용된다.**

: 즉, 클라이언트용 장비에 최적화된 GC 이기 때문에 만약 WAS 에서 이 방식을 사용하면 GC 속도가 매우 느려 Web Application 이 엄청 느려진다.
