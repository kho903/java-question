# 자바의 역사
- 1991년 "Green" 프로젝트가 자바의 모태. 제임스 고슬링, Mike Sheridan, Patrick Naughton 3명의 젊은이가 TV와 상호 작용 할 수 있는 것을 만들기 위해 시작
- 1992년 고슬링의 사무실 앞에 있는 참나무를 보고 이름을 지은 "Oak"라는 언어
- 1995년 "Oak"에서 "자바 커피"의 이름을 본따 "Java"로 바뀌면서 자바 기술의 시작. "Write Once, Run Anywhere" (WORA) 모토가 탄생하였으며,
여러 플랫폼에서 수행할 수 있는 개발 언어를 목표로 개발됨
- 1996년 JDK 1.0 출시. (JDK : Java Development Kit)
- 1997년 JDK 1.1이 3주만에 22만 다운로드를 기록. 폭발적인 성장을 예견.
- 1998년 12월 J2SE 라는 이름으로 자바 기본 버전 명칭 변경 및 J2SE 1.2 출시. (J2SE : Java 2 Standard Edition)
  J2EE라는 Enterprise Edition, 블랙베리와 같은 전화기의 J2ME라는 Micro Edition과의 혼동을 막기 위해서 명칭 변경.
- 2000년 J2SE 1.3, 2002년 J2SE 1.4, 2004년 J2SE 5 출시. 1.5 버전부터는 1. 을 뺀 뒤의 숫자만 붙게 되었다.
- 2004년 약간의 개선이 이루어진 Java SE 6 출시.
- 2011년 오랜 기간동안의 업그레이드 준비를 마친 Java SE 7 출시.
- 2014년 3월 Java SE 8 정식 출시
- Java SE 6까지는 Sun Microsystems 에서 자바에 대한 주요 스펙을 만들고 Java를 만들어 왓지만, Java SE 7부터는 Oracle에서 Sun Microsystems를 인수하여
지금에 이르고 있다.

# JDK의 플랫폼에 따른 차이
- 자바는 Oracle에서만 만드는 것이 아니다. 우리나에서 많이 사용하는 서버에는 IBM 및 HP 에서 만든 서버와 예전 Sun이 만든 Solaris가 있다. 
- 각 Java 버전에서 제공되어야 하는 표준 문서가 만들어지면 그 기준에 해당하는 각 벤더에 맞는 JDK가 별도로 만들어지는 것이다. 리눅스의 경우 Oracle 기본 JDK 주로 사용
- 어떤 OS에서 개발하든지 JDK 버전만 맞으면 적용할 OS에서 컴파일만 하면 애플리케이션 실행에 문제 없다. 하지만 회사별 JDK의 내부 동작 구조는 상이하다.
- 이외에도 OpenJDK, JRockit 이라는 JDK가 있다. OpenJDK는 라이선스 문제가 되는 부분을 제거한 완전 오픈소스 버전의 JDK. 최근 버전의 리눅스 OS에는 OpenJDK가
기본으로 설치되어 있다. JRockit은 WebLogic 이라는 WAS의 성능 최적화를 위해 만든 JDK인데, WebLogic을 BEA라는 회사에서 만들어 판매하다가 Oracle로 넘어갔다.
따라서 Oracle JDK와 JRockit은 한지붕 아래의 서로 다른 JDK가 공존하고 있는 상황이다.

# JDK, J2SE, Java SE 외에 자바에서 사용되는 다른 용어들
- JDK : Java Development Kit
- J2SE : Java 2 Standard Edition
- Java SE : Java Standard Edition
- Java에서 2가 빠진 것은 Java SE 6가 출시되면서부터이며, 빠진 이유는 마케팅을 위해서 Java로 통칭
- 자바를 개발하기 위해서 설치를 하다보면 JDK, JRE로 구분되어 있는데 이는,
  - JDK : Java Development Kit
  - JRE : Java Runtime Environment
- JRE는 실행만을 위한 환경으로 JRE만 설치하면 자바를 컴파일하는 등의 각종 프로그램이 제외된 상태로 설치된다. 즉, 실행할 수 있는 환경의 집합. 그리고,
여러 가지 레고 블록처럼 칸칸이 쌓여 있는 것들은 자바에서 제공하는 라이브러리들이다. 

# 자바언어의 특징은 다음과 같다.
## 자바는 "단순하고 객체지향이며 친숙"해야 한다. (simple, object-oriented and familiar)
- 단순함이란 자바에 대한 기본 컨셉을 배우는 것이 어렵지 않다는 것을 의미
- 자바는 처음 만들때부터 객체지향으로 디자인되어 있다. 다형성, 캡슐화 등 객체지향 언어의 특징들을 지원할 수 있는 구조. 물론 개발자가 객체지향 프로그램을
작성하지 않으면 이러한 이점은 모두 사라진다. 즉, 자바를 쓴다고 해서 무조건 객체지향적으로 개발된다는 것은 아니다.
- 자바로 개발할 때에는 처음부터 모든 것을 만들 필요가 없다. 개발하면서 필요한 여러 기능들은 이미 API를 통해서 제공. 파일을 읽고 쓰거나 네트워크로
데이터를 주고 받는 I/O, 그래픽 UI 등을 개발하기 위한 여러 라이브러리를 통해서 보다 쉽게 개발할 수 있는 환경을 제공
- C++과 비슷하지만 C++은 불필요하게 복잡한 부분이 있다. 자바는 C++보다는 쉽고 빠르게 개발할 수 있다는 장점이 있다.

## 자바는 "견고하며, 보안상 안전"하다. (robust and secure)
- 자바는 컴파일할 때와 실행할 때 문법적 오류에 대한 체크를 한다. 메모리 관리 모델이 매우 단순하고, C에 있는 포인터의 개념이 없다. 이러한 특징들은 자바를
매우 믿을 수 있고 (reliable) 견고한 소프트웨어가 될 수 있도록 도와준다.
- 기본적으로 분산 환경에서 사용하기 위해서 디자인되었다. 분산 환경에서 보안은 매우 중요한 부분 중 하나다. 자바 기술은 외부에서 침입이 불가능한 애플리케이션을
만들 수 있도록 해준다. 네트워크 환경에서 클라이언트로 다운로드한 승인받지 않은 프로그램은 실행할 수 없도록 되어 있다. 따라서 바이러스를 생성하거나 파일 시스템을
공격할 수가 없다.
- 기본적으로 이렇게 선언되어 있지만, 간혹 JDK 내부 또는 라이브러리의 오류로 인해 취약점이 발견되기도 한다.

## 자바는 "아키텍처에 중립적이어야 하며 포터블"해야 한다. (architecture-neutral and portable)
- 자바로 작성한 프로그램은 매우 다양한 하드웨어 아키텍처에서 수행할 수 있도록 되어 있다. 따라서 자바는 아키텍처에 중립적인 바이트 코드를 생성한다. 따라서,
자바의 버전만 동일하다면, 동일한 프로그램은 어떤 플랫폼에서도 실행할 수 있다.
- 아키텍처 중립적은 포터블한 시스템의 일부분일 뿐이다. 따라서, 기본 데이터 타입의 크기를 지정해 놓고, 숫자 연산자에 대한 행위들을 정의해 두었다. 따라서
어떤 플랫폼에서도 동일한 결과가 나오며, 하드웨어와 소프트웨어 아키텍처에 따른 데이터 타입의 호환성 문제가 발생하지 않는다.
- 이러한 호환성과 포터블한 환경을 제공하는 것은 JVM 덕분이다.

## 자바는 "높은 성능"을 제공해야 한다.
- 성능은 항상 고려를 해야 하는 부분이다. 자바는 실행 환경에서 최대한의 성능을 낼수 있도록 되어 있다.
- 자동화된 가비지 컬렉터는 낮은 우선 순위로 쓰레드로 동작하기 때문에 보다 높은 성능을 낼 수 있다.
- 보다 빠른 성능을 위해 네이티브 언어로 작성한 부분을 자바에서 사용할 수도 있도록 되어 있다.

## 자바는 "인터프리트 언어이며, 쓰레드를 제공하고, 동적인 언어"이다.
- 자바 인터프리터는 자바 바이트 코드를 어떤 장비에서도 수행할 수 있도록 해준다. 따라서 기존에 사용하던 무거운 컴파일과 링크와 테스트 사이클을 거쳐야 하는 개발
환경보다 빠른 환경을 구축할 수 있다.
- 자바는 멀티 쓰레드 환경을 제공하기 때문에 동시에 여러 작업 수행 가능. 따라서, 사용자에게 매우 빠른 사용 환경을 제공한다.
- 자바 컴파일러는 컴파일시 매우 엄격한 정적인 점검을 수행한다. 그리고, 실행시에 동적으로 필요한 프로그램들을 링크시킨다. 게다가 새로운 코드는 다양한 소스에서
요청에 의해서 연결될 수 있다.

# 자바의 버전별 차이
## JDK 1.0
- 가장 최초의 버전. JDK 1.0.2 버전은 최초의 안정 버전이며 Java 1이라고 불리게 됨

## JDK 1.1에서 추가된 것들
1. AWT 의 이벤트 모델의 확장 및 변경
2. 내부 클래스 (inner class) 추가
3. JavaBeans, JDBC, RMI 등 추가
- AWT는 Abstract Window Toolkit 의 약자로 자바를 이용하여 UI 구성할 때 사용되는 기반 기술
- JavaBeans는 자바에서 제공하는 컴포넌트 모델 중 하나
- JDBC는 Java Database Connectivity의 약자로, 자바에서 데이터베이스에 데이터를 담기 위한 API
- RMI는 Remote Method Invocation의 약자로 같은 JVM에 있는 메소드를 호출하는 것이 아니라, 원격 JVM에 있는 메소드를 호출하기 위한 기술을 의미

## JDK 1.2에서 달라진 것들과 추가된 것들
- JDK 1.2 ~ 1.5 까지는 J2SE로 불렸으며, 새로운 자바라는 의미로 Java 2 라는 이름도 생겼다. 추가된 사항은 다음과 같다.
1. strictfp 예약어 추가
2. GUI 제공 위한 Swing이 코어 라이브러리에 추가
3. JIT라는 컴파일러가 Sun JVM에 처음 추가
4. 자바 플러그인 (Java Plug-in) 추가
5. CORBA라는 지금은 별로 사용하지 않는 기술과 데이터를 주고 받기 위한 IDL 추가
6. 자바에서 각종 자료 구조를 쉽게 처리하기 위한 Collections 라는 프레임웍 추가
- JIT는 Just-In-Time의 약자로, 어떤 메소드의 일부 혹은 전체 코드를 네이티브 코드로 변환하여 JVM에서 번역하지 않도록 함으로써 보다 빠른 성능을 제공하는 기술

## JDK 1.3에서 추가된 것들
1. HotSpot JVM 추가 (정확히는 JDK 1.2에서 추가되었지만 공식적으로 1.3에서 추가되었다.)
2. CORBA와의 호환성 위해 RMI 수정
3. 사운드 처리 위한 JavaSound 라이브러리 추가
4. JNDI (Java Naming and Directory Interface)가 코어 라이브러리에 추가
5. 자바의 디버깅을 보다 쉽게 하기 위한 JPDA (Java Platform Debugger Architecture) 추가
6. Synthetic 프록시 클래스 추가
- JNDI는 어떤 객체를 쉽게 찾을 수 있도록 도와주는 이름을 지정한 후, 나중에 그 이름으로 객체를 찾아가는 것을 의미
- 자바에서는 RMI, CORBA와 같은 것을 사용할 때나, LDAP, DNS 등 각종 주소를 쉽게 지정하기 위해서 사용된다.

## JDK 1.4 버전에서 추가된 것들
- 많은 라이브러리들이 추가되었다. 자바 커뮤니티 프로세스 (JSR)라는 절차에 따라서 개발된 첫 번째 릴리즈이기도 하다. 
1. assert 예약어 추가
2. Perl 언어의 정규 표현식을 따르는 정규 표현식 (regular expression) 추가
3. exception chaining 이라는 것을 통하여 하위 레벨의 예외의 캡슐화가 가능해짐
4. IPv6 (Internet Protocol version 6) 지원 시작
5. NIO (New Input/Output) 라는 non-blocking 추가
6. 각종 로그를 처리하기 위한 logging API 추가
7. JPEG이나, PNG와 같은 이미지를 읽고 쓰기 위한 image I/O API 추가
8. 통합 XML 파서와 JAXP라는 XSLT 프로세서 추가
9. JCE, JSSE, JAAS 와 같은 통합 보안 및 cryptography extenstions 추가
10. Java Web Start 추가 (JDK 1.3에서 처음 소개)
11. 각종 설정 값들을 저장하고 읽는 데 사용되는 Preferences API (java.util.prefs) 추가
- 정규 표현식은 어떤 문자열에서 특정 조건에 맞는 값이 있는 지 확인하는 데 사용. 어떤 문자열이 이메일 주소의 조건에 맞는지, 웹 페이지 주소를 나타내는 URL
조건에 맞는지 등을 확인할 때 사용
- NIO는 이전 버전까지의 IO를 처리할 때 사용한 java.io 패키지에서 제공하는 기능의 단점을 보완하기 위한 것. 기존 IO보다 어렵지만, 성능은 비교할 수 없을
정도로 빠르다는 장점이 있다.

## Java 5 버전에서 추가 및 향상된 점들
- 매우 많은 변화가 있었다.
1. 보다 안전하게 컬렉션 데이터를 처리할 수 있는 제네릭 (generic) 추가
2. 어노테이션 (annotation)이라고 불리는 메타데이터 기능 추가
3. 기본 자료형과 그 기본 자료형을 객체로 다루는 클래스 간의 데이터 변환이 자동으로 발생하는 autoboxing 및 unboxing 기능 추가 (예 : int <-> Integer)
4. 상수 타입을 나타내는 enum 추가
5. 매개 변수의 개수를 가변적으로 선언할 수 있는 varargs 추가 (String ... strs 형식의 매개 변수 선언)
6. for 루프에 세미콜론이 아닌 콜론으로 구분하여 배열이나 컬렉션 타입에 저장되어 있는 데이터를 순차적으로 꺼내는 향상된 for 루프 추가
7. import 앞에 static을 붙여 정적 import가 가능하도록 해 주는 static import 추가
8. 쓰레드 처리를 쉽게 할 수 있는 concurrent 패키지 (java.util.concurrent) 추가
9. 스트림이나 버퍼로 들어오는 데이터의 분석 (parse)을 보다 간편하게 할 수 있는 Scanner 클래스 추가

## Java 6 버전에서 향상된 점들
1. 스크립팅 언어가 JVM 위에서 수행 가능하게 됨
2. 각종 코어 기능의 성능 개선
3. Compiler API가 추가되어 프로그램에서 자바 컴파일러 실행 가능
- Java 6는 안정성과 확장성이 목정.

## Java 7 향상점
- 별도로 다룸

## Java 8에서 추가된 점들
- 가장 큰 변화는 람다 (lambda) 표현식이 사용이 가능하다는 것.
- 별도로 다룸

# JIT 컴파일러는 도대체 뭘까?
- Just-In-Time의 약자로 자바와 .NET 등에서 사용. 쉬운말로 하면 "동적 변환(dynamic translation)"이라고 보면된다. 이러한 JIT를 만든 이유는
프로그램 실행을 보다 빠르게 하기 위해서다. 명칭은 컴파일러이지만, 실행시에 적용되는 기술.
- 컴퓨터 프로그램 실행 방식은 2가지로, 인터프리트(interpret) 방식과 정적(static) 컴파일 방식이다. 인터프리트 방식은 프로그램 실행마다 컴퓨터가 알아들을 수 있는
언어로 변환하는 작업을 수행. 간편하지만, 성능이 매우 느리다. 정적 컴파일 방식은 실행하기 전에 컴퓨터가 알아들을 수 있는 언어로 변환 작업을 미리 실행. 즉, 변환 작업은
딱 한 번만 수행. JIT는 이 두 가지 방식을 혼합한 것이다. 변환 작업은 인터프리터에 의해 지속적으로 수행되지만, 필요한 코드의 정보는 캐시에 담아두었다가 재사용.
- javac라는 명령어를 사용하여 컴파일하는 단계에서 만들어진 class 파일은 바이트 코드(bytecode)일 뿐이다. 자바의 모토인 "Compile once, Run Anywhere"에 따라
한 번 컴파일한 코드로 모든 OS에서 사용 가능하다. 다시 말해, javac를 수행하는 것은 텍스트로 만든 java 파일을 바이트 코드라는 파일로 만든 것뿐이다.
컴퓨터가 알아들을 수 있도록 하려면 다시 변환 작업이 필요한데, 이 변환 작업을 JIT 컴파일러에서 한다고 보면 된다.
- 즉 자바 프로그램이 수행되는 절차를 보면, 자바 소스코드 -> 자바 컴파일러 -> 컴파일된 Bytecode -> JVM -> 기계 코드 -> 하드웨어 및 OS 에서 JVM -> 기계 코드로
변환되는 부분을 JIT에서 수행하는 것이다. JIT를 사용하면, 반복적으로 수행되는 코드는 매우 빠른 성능을 보인다는 장점이 있지만, 반대로 처음에 시작할 때에는 변환 단계를
거쳐야 하므로 성능이 느리다는 단점이 있다. 하지만, 최근 CPU 성능이 많이 좋아졌고, JDK의 성능 개선도 많이 이루어졌기 때문에 단점도 많이 개선되었다.

# HotSpot은 또 뭐야?
- JDK 1.3부터 공식적으로 자바에서 HotSpot JVM이 제공된다. 자바에서는 "HotSpot 클라이언트 컴파일러"와 "HotSpot 서버 컴파이러"의 두 가지 컴파일러를 제공한다.
과거의 대부분 PC CPU가 하나였던 사용자를 위해 만들어진 것이 HotSpot 클라이언트 컴파일러다. 이 컴파일러의 주요 특징은 애플리케이션 시작 시간을 빠르게 하고,
적은 메모리를 점유하도록 하는 것이다. 그리고, 코어가 많은 장비에서 애플리케이션을 돌리기 위해서 만들어진 것이 HotSpot 서버 컴파일러라고 생각하면 되며, 이 컴파일러는
애플리케이션 수행 속도에 초점이 맞추어져 있다.
- HotSpot이라는 이름을 사용하는 것은 JDK 1.3 이전에 나왔던 가상 머신과 구분하기 위한 이름이다. 자바를 만드는 오라클 사이트에서는 이전 버전의 JVM을 
Classic VM 이라고 표현하고 있다.
- 클라이언트 컴파일러와 서버 컴파일러는 자바가 시작할 때 알아서 확인한다. 그 기준은 다음을 만족하면 서버 컴파일러를 선택한다.
  - 2개 이상의 물리적 프로세서
  - 2GB 이상의 물리적 메모리
- 명시적으로 지정하기 위해서는 -client, -server를 다음과 같이 지정하면 된다.
```shell
$ java -server Calculator
```
- 이 외에도 해당 자리에 공백으로 구분하여 다른 옵션을 추가할 수 있다. 다음과 같이 -Xms 옵션으로 512 메가 바이트의 시작 크기를 지정 가능
```shell
$ java -server -Xms512m Calculator
```
- OS 에 따라 미리 정해져 있기도 하는데, 윈도우는 지정해주지 않으면 클라이언트 컴파일러가 사용됨

# 자바를 배우면 꼭 알아야 하는 용어
1. JVM : Java Virtual Machine (자바 가상 머신)
2. GC : Garbage Collector (가비지 컬렉터)
- JVM은 자바 프로그램이 수행되는 프로세스를 의미. java 명령어로 애플리케이션이 수행되면, 이 JVM 위에서 애플리케이션이 동작. 이 JVM에서 우리가 작성한 프로그램을
찾고 실행하는 일련의 작업이 진행된다.
- 자바의 메모리 관리는 개발자가 하지 않아도 된다. JVM이 알아서 하기 때문이다. JVM 내에서 메모리 관리를 해주는 것을 바로 "가비지 컬렉터"라고 부른다. 사용하고
남아 있는 전혀 필요 없는 객체를을 쓰레기라고 부른다. 아무리 가비지 컬렉터가 쓰레기를 알아서 청소하더라도, 메모리를 효율적으로 사용하도록 개발하는 것은 매우 중요하다.
- 일반적으로 GC라는 말의 의미는 Garbage Collection (가비지 컬렉션)을 의미. 쓰레기를 청소하는 작업 수행시 가비지 컬렉션이 수행되었다 또는 "GC가 발생했다."고 표현. 

# 자바의 GC는 어떻게 진행되나요?
- 자바의 GC 수행 방식은 매우 여러 가지가 있다.
- 어떤 객체를 생성하더라도 그 객체는 언젠가는 쓰레기가 되어 메모리에서 지워져야만 한다. 만약 지워지지 않으면, 자바 프로그램은 엄청난 메모리가 필요할 것이다.
그래서 C와 같은 언어에서는 메모리 해제 작업이 필수다. 하지만 자바는 그런 작업을 가비지 컬렉터가 알아서 쓰레기를 치워준다.
- Java 7 부터 공식적으로 사용할 수 있는 G1(Garbage First)라는 가비지 컬렉터를 제외한 나머지 JVM은 영역을 나누어 힙 (Heap)이라는 공간에
객체들을 관리한다. 
- 가장 왼쪽에 있는 Young 영역에는 말 그대로 젊은 객체들이 존재하며, Old 영역에는 늙은 객체들이 자리잡게 된다. Perm 영역에는 클래스나 메소드에 대한 정보가 쌓인다.
- Young 영역은 Eden과 두 개의 Survivor 영역으로 나뉘는데, 객체를 생성하자마자 저장되는 장소는 Eden 이다. 일반적으로 자바에서 메모리가 살아가는 과정은 다음과 같다.
1. Eden 영역에서 객체가 생성된다.
2. Eden 영역이 꽉 차면 살아있는 객체만 Survivor 영역으로 복사되고, 다시 Eden 영역을 채우게 된다.
3. Survivor 영역이 꽉 차게 되면 다른 Survivor 영역으로 객체가 복사된다. 이때, Eden 영역에 있는 객체들 중 살아있는 객체들도 다른 Survivor 영역으로 간다.
즉, Survivor 영역의 둘 중 하나는 반드시 비어 있어야만 한다.
- 위 과정을 마이너(minor) GC 혹은 영(Young) GC 라고 한다. 여기서 GC는 가비지 컬렉터가 아니라 가비지 컬렉션을 의미한다.
- 그러다가 오래 살아있는 객체들은 Old 영역으로 이동한다. 지속적으로 이동하다가 Old 영역이 꽉 차면 GC가 발생하는데, 이것을 메이저 (major) GC, 풀 GC라고 부른다.
- 영GC가 풀GC 보다 더 빠르다. 일반적으로 더 작은 공간이 할당되고, 개게들을 처리하는 방식도 다르기 때문이다. 그렇다고 전체의 힙 영역을 영 영역으로 만들면 장애로 이어질
확률이 매우 높아진다.
- 오라클 JDK에서 제공하는 GC의 방식은 크게 4가지, Java 7부터 추가된 G1(Garbage First)를 포함하여 총 5가지의 가비지 컬렉터가 존재한다.
1. Serial GC
2. Parallel Young Generation Collector
3. Parallel Old Generation Collector
4. Concurrent Mark & Sweep Collector (CMS)
5. G1 (Garbage First)
- WAS에서는 Serial GC를 사용해서는 안된다. 이 GC 방식은 -client 옵션을 지정했을 때 사용됨. 즉, 클라이언트용 장비에 최적화된 GC로, WAS에서 사용시, 속도가 매우
느려, 웹 애플리케이션이 엄청 느려진다. 그외 다른 GC들은 서로 장단점이 존재해서, 어떤 GC 방식이 가장 적합하다고 이야기하기 어렵다.

